<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="icon" href="../images/favicon.ico" />
<link type="text/css" rel="stylesheet" href="../styles/module.css" />    

<!-- for equation support -->
<link rel="stylesheet" href="../styles/jqmath-0.4.3.css" />
<script type="text/javascript" src="../styles/jquery-1.4.3.min.js"></script>
<script type="text/javascript" src="../styles/jqmath-etc-0.4.6_tcad.min.js" charset="utf-8"></script>
<script type="text/javascript">M.MathPlayer = false; M.trustHtml = true;  M.$mathQ = true</script>    

<title>TCAD Sentaurus Tutorial &ndash; Sentaurus Mesh 7. Using the Tensor-Product Mesh Generator</title>
</head>

<body>
<div id="all">

<!--================================================-->
<div id="menutop">
<p><img src="images/banner.png" width="600" height="53" alt="Banner" />

<a href="../index.html">main menu</a>
&nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;<a href="smesh_menu.html">module menu</a>
&nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;<a href="smesh_06.html">&lt;&lt; previous section</a>
&nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;<a href="smesh_08.html">next section &gt;&gt;</a>
</p>
</div>

<!--================================================-->
<h1 class="title">Sentaurus Mesh<br />7. Using the Tensor-Product Mesh Generator</h1>

<p>
 <a href="#1">7.1 Overview</a><br />
 <a href="#2">7.2 Basic Mesh Controls</a><br />
 <a href="#3">7.3 Mesh Generation for EMW</a><br />
 <a href="#4">7.4 Detecting Short Edges</a><br />
 <a href="#5">7.5 Including Doping Information</a><br />
 <a href="#6">7.6 Tensor Mesh for Garand VE</a>
</p>

<!--================================================-->
<h2 class="obj">Objectives</h2>

<ul>
 <li>To introduce the tensor-product mesh generation capabilities 
     of Sentaurus Mesh.</li>
</ul>
<!--================================================-->
<a name="1"></a>
<h1>7.1 Overview</h1>

<p>Tensor-product meshes generated by Sentaurus Mesh are used primarily 
by Sentaurus Device Electromagnetic Wave Solver (EMW) and the TCAD to SPICE 
device simulators (Garand&nbsp;VE and Garand&nbsp;MC).</p>

<p>To generate a tensor-product mesh using Sentaurus Mesh, you must specify the 
<tt>EnableTensor</tt> option in the <tt>IOControls</tt> section. Alternatively, 
you can use <tt>EnableSections</tt> in the <tt>IOControls</tt> section, which
instructs Sentaurus Mesh to respect <em>all</em> specified sections. All the
necessary controls for tensor-product mesh generation are specified in the
<tt>Tensor</tt> section of the command file, which can include different
subsections:</p>

<pre>
Tensor {
  Mesh {...}
  EMW {...}
}
</pre>

<p>where:</p>

<ul>
<li>The <tt>Mesh</tt> subsection defines the general tensor-grid controls.</li>
<li>The <tt>EMW</tt> subsection defines dedicated controls for EMW applications.</li>
</ul>

<p>For very large structures, you can speed up meshing by running Sentaurus Mesh
in parallel. To do so, you can specify the number of threads in the <tt>IOControls</tt> 
section with <tt>numThreads=&lt;integer&gt;</tt>.</p>

<!--================================================-->
<a name="2"></a>
<h1>7.2 Basic Mesh Controls</h1>

<p>The <tt>Mesh</tt> subsection defines the basic tensor-mesh controls, the most
important of which will be introduced here. For details, see the 
&quot;Tensor Section&quot; section, in Chapter&nbsp;2, of the 
<cite>Sentaurus&trade; Mesh User Guide</cite>.</p>

<p>All the Sentaurus Mesh commands discussed in this section are contained in the 
Sentaurus Workbench project <tt>Applications_Library/GettingStarted/snmesh/TensorMesh</tt>. 
To work with the project, start Sentaurus Workbench and copy the project 
<tt>TensorMesh</tt> to a local directory within the Sentaurus Workbench working directory.</p>

<p>The command file is partitioned by the Sentaurus Workbench parameter <tt>example</tt>. 
To experiment with commands, add a new example in the Sentaurus Workbench project table, 
and add your commands in a new example section in the command file.</p>

<!--==========================-->
<h2>7.2.1 Default Settings</h2>

<p>Starting with an empty <tt>Mesh</tt> subsection (compare <tt>example=2</tt>), 
Sentaurus Mesh uses reasonable default values. The most important defaults are:</p>

<ul>
<li><tt>maxCellSize</tt>: 10% of geometry in each direction</li>
<li><tt>grading</tt>: Switched on</li>
</ul>

<p>For a test 2D CMOS image sensor (CIS) boundary, this results in a tensor mesh as shown 
in Figure&nbsp;1 (<em>left</em>). Note the overall discretization of approximately 10 nodes 
in each direction due to the default value of <tt>maxCellSize</tt> and the clearly visible 
graded region around the top silicon interface.</p>

<p><a href="images/sm_tp_2-3.png"><img src="images/sm_tp_2-3.png" width="570" 
alt="Tensor meshes for examples 2 and 3" /></a></p>

<p class="caption">Figure 1. (Left) example=2 uses the default settings and 
(right) example=3 has grading switched off. (Click image for full-size view.)</p>

<!--==========================-->
<h2>7.2.2 Grading</h2>

<p>By default, Sentaurus Mesh tries to create a smooth transition between cells of 
different element sizes. This is controlled by the keyword <tt>grading &lt;grad&gt;</tt>, 
where <tt>&lt;grad&gt;</tt> is a floating-point number specifying the maximum cell-size 
ratio of two adjacent elements. An individual grading factor can be specified for each 
direction using:</p>

<ul>
<li><tt>grading = {&lt;gradx&gt; &lt;grady&gt;}</tt> for 2D structures</li>
<li><tt>grading = {&lt;gradx&gt; &lt;grady&gt; &lt;gradz&gt;}</tt> for 3D structures</li>
</ul>

<p>To switch off grading, specify <tt>grading=off</tt> in the <tt>Mesh</tt> subsection 
(see Figure&nbsp;1, <em>right</em>). Comparing the graded mesh (Figure&nbsp;1, <em>left</em>) 
to it, additional horizontal lines are inserted in the top region of silicon due to the 
very small cells in the region on top of silicon. Similarly, vertical lines are added 
adjacent to the metal lines around x &gt; &ndash;0.7 and x &lt; 0.7.</p>

<!--==========================-->
<h2>7.2.3 Setting Cell Sizes</h2>

<p>The size of  tensor-grid elements in the bulk is a key parameter to be adjusted. 
As multiple refinements can be specified for a particular domain, you always specify 
an element size range with <tt>minCellSize</tt> and <tt>maxCellSize</tt>. Sentaurus Mesh 
tries to fullfill all of the specified requirements, however, it might not always be 
possible due to contradicting constraints or other limitations.</p>

<p>For example, with the following commands, you switch off grading and ensure that nowhere 
does the cell size drop below 0.01 &mu;m, keeping the maximum cell size below 0.1 &mu;m 
in each direction (see Figure&nbsp;2, <em>left</em>).</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/tensor_msh.cmd" startExpr="*example*4*" startoffset=1 endExpr="*#-*" endoffset=-1-->
<pre>
    grading off
    minCellSize = 0.01 
    maxCellSize = 0.1
    
</pre>
<!-- grep end -->

<p><a href="images/sm_tp_4-5.png"><img src="images/sm_tp_4-5.png" width="570" 
alt="Tensor meshes for examples 4 and 5" /></a></p>

<p class="caption">Figure 2. (Left) example=4 uses minCellSize and maxCellSize 
settings and (right) example=5 uses maxCellSize in silicon. (Click image for 
full-size view.)</p>

<!--==========================-->
<h2>7.2.4 Restricting Cell Size Refinements</h2>

<p>Bulk refinements can be restricted to certain regions or materials and also
to particular directions (see <tt>example=5</tt>). These local refinements
overwrite global settings. Therefore, with the following line, the aluminum regions 
are refined more in the x- and y-directions (see Figure 2, <em>right</em>):</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/tensor_msh.cmd" startExpr="*maxCellSize*material*Aluminum*" lines=1 -->
<pre>
    maxCellSize material &quot;Aluminum&quot; 0.01 
</pre>
<!-- grep end -->

<p>However, looking more closely at the metal regions, you can see that the element 
size in the metal is approximately 0.05 &mu;m and not 0.01 &mu;m as actually requested, 
because the global <tt>minCellSize = 0.05</tt> conflicts with <tt>maxCellSize=0.01</tt> in the 
aluminum regions. The <tt>minCellSize</tt> requirements have a higher priority than the 
<tt>maxCellSize</tt> requirements. This ensures that a certain element size is not 
undercut, because the minimum cell size determines the time step in EMW simulations. 
This is why the final element size in metal is 0.05 &mu;m, as defined by <tt>minCellSize</tt>.</p>

<p>Note that the <tt>minCellSize=0.05</tt> setting also affects the thin region 
&quot;M2&quot; immediately above the silicon; it contains only one element in the 
y-direction instead of two as previously set.</p>

<p>With the following line, <tt>example=6</tt> shows region- and direction-restricted 
refinement:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/tensor_msh.cmd" startExpr="*maxCellSize*region*direction*" lines=1 -->
<pre>
    maxCellSize region direction &quot;M6&quot; &quot;y&quot; 0.02 
</pre>
<!-- grep end -->

<p>This refines the lens "M6" in the y-direction (see Figure 3, <em>left</em>).</p>

<p><a href="images/sm_tp_6-7.png"><img src="images/sm_tp_6-7.png" width="570" 
alt="Tensor meshes for examples 6 and 7" /></a></p>

<p class="caption">Figure 3. (Left) example=6 uses region- and direction-restricted
refinement and (right) example=7 uses interface refinement. (Click image for 
full-size view.)</p>

<!--==========================-->
<h2>7.2.5 Interface Refinements</h2>

<p>In addition to bulk refinement, the parameter <tt>maxBndCellSize</tt> offers 
interface (or boundary) refinement. In <tt>example=7</tt>, you use this parameter 
to refine the interfaces of the aluminum regions (see Figure 3, <em>right</em>):</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/tensor_msh.cmd" startExpr="*maxBndCellSize*" lines=1 -->
<pre>
    maxBndCellSize interface material &quot;Aluminum&quot; &quot;Insulator2&quot; 0.01 
</pre>
<!-- grep end -->

<p>Refinement occurs on both sides of the interface. A similar syntax can be used for 
region interfaces:</p>

<pre>
maxBndCellSize interface region &quot;region1&quot; &quot;region2&quot; 0.01 
</pre>

<!--==========================-->
<h2>7.2.6 Refinement Windows</h2>

<p>In addition to materialwise or regionwise refinements, Sentaurus Mesh offers 
the possibility to restrict refinements to user-defined rectangular windows. In 
<tt>example=8</tt>, the goal is to refine the photodiode area in the middle of the 
silicon bulk material (see Figure 4, <em>left</em>):</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/tensor_msh.cmd" startExpr="*window*" lines=3 -->
<pre>
    window &quot;PD&quot; -0.5 0.5 0.2 0.5
    maxCellSize window direction &quot;PD&quot; &quot;x&quot; 0.05
    maxCellSize window direction &quot;PD&quot; &quot;y&quot; 0.02
</pre>
<!-- grep end -->

<p>You first define a window named &quot;PD&quot; with coordinates in the order 
<tt>&lt;xmin&gt; &lt;xmax&gt; &lt;ymin&gt; &lt;ymax&gt;</tt> (plus 
<tt>&lt;zmin&gt; &lt;zmax&gt;</tt> for 3D structures). Then, similar to region or material
restriction, you use the parameter <tt>window</tt> to limit <tt>maxCellSize</tt> 
refinements to that window.</p>

<p><a href="images/sm_tp_8-9.png"><img src="images/sm_tp_8-9.png" width="570" 
alt="Tensor meshes for examples 8 and 9" /></a></p>

<p class="caption">Figure 4. (Left) example=8 uses window-restricted refinement 
and (right) example=9 has an equidistant mesh. (Click image for full-size view.)</p>

<!--==========================-->
<h2>7.2.7 Equidistant Mesh</h2>

<p>Sentaurus Mesh can also generate equidistant meshes by specifying the number 
of mesh points in each direction (see Figure&nbsp;4, <em>right</em>):</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/tensor_msh.cmd" startExpr="*example*9*" startoffset=1 endExpr="*#*" endoffset=-1 -->
<pre>
    numPointsX = 20
    numPointsY = 50
</pre>
<!-- grep end -->

<p>The benefit of equidistant meshes is that generation is very fast. However, 
boundaries are adjusted to the equidistant grid. In this example, the size of the 
metal regions differs substantially, and the thin &quot;M2&quot; layer above the 
silicon is missing completely. Therefore, typically, these meshes are used for 
preliminary coarse estimates, or the element size must be chosen fine enough to 
minimize geometric errors.</p>

<!--================================================-->
<a name="3"></a>
<h1>7.3 Mesh Generation for EMW</h1>

<p>Sentaurus Mesh allows the generation of tensor grids whose cell size depends 
on the optical path length of the incident light. In other words, you want to 
discretize the structure with a fixed number of points per wavelength. Such an 
approach is dedicated to the spatial mesh discretization suitable for Sentaurus Device
Electromagnetic Wave Solver (EMW).</p>

<p>To run Sentaurus Mesh in EMW mode, you must use the <tt>EnableEMW</tt> option
in the <tt>IOControls</tt> section. Alternatively, you can use 
<tt>EnableSections</tt> in the <tt>IOControls</tt> to instruct Sentaurus Mesh to
respect <em>all</em> specified sections.</p>

<p>The tensor-mesh generation for EMW simulations is controlled in the <tt>EMW</tt> 
subsection in the <tt>Tensor</tt> section of the Sentaurus Mesh command file:</p>

<pre>
Tensor {
  EMW {...}
}
</pre>

<p>All the Sentaurus Mesh commands discussed in this section are contained in the 
Sentaurus Workbench project <tt>Applications_Library/GettingStarted/snmesh/TensorEMW</tt>. 
To work with the project, start Sentaurus Workbench and copy the project 
<tt>TensorEMW</tt> to a local directory within the Sentaurus Workbench working directory.</p>

<p>The command file is partitioned by the Sentaurus Workbench parameter <tt>example</tt>. 
To experiment with commands, add a new example in the Sentaurus Workbench project table, 
and add your commands in a new example section in the command file.</p>

<!--==========================-->
<h2>7.3.1 Setting the Complex Refractive Index</h2>

<p>The complex refractive index (CRI) must be defined first with:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*cri*wavelengthdep*" lines=1 -->
<pre>
    CRI WavelengthDep real imag
</pre>
<!-- grep end -->

<p>Similar to Sentaurus Device, you can instruct Sentaurus Mesh to use only the real part, 
or only the imaginary part, or both the real and imaginary parts for the optical path 
calculation by specifying the required parts. The effect on refinement is 
discussed here.</p>

<p>Similar to <tt>maxCellSize</tt>, the CRI model can be restricted to a certain region 
or material:</p>
 
<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*cri*material*" lines=1 -->
<pre>
    CRI material &quot;Aluminum&quot; WavelengthDep real
</pre>
<!-- grep end -->

<p>The CRI model constants are read from the <tt>ComplexRefractiveIndex</tt> sections 
of a Sentaurus Device parameter file. The file name can be set by the following command:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*parameter*" lines=1 -->
<pre>
    Parameter Filename = &quot;@parameter@&quot;
</pre>
<!-- grep end -->

<p>If no parameter file is defined, the defaults from Sentaurus Device are used. 
For convenience, a predefined Sentaurus Workbench parameter <tt>@parameter@</tt> 
can be used to refer to a preprocessed version of the parameter file called 
<tt>snmesh.par</tt>.</p>

<p>Finally, to evaluate the CRI model and to calculate the n&amp;k values, a 
wavelength in micrometers must be specified:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*wavelength*" lines=1 -->
<pre>
    Wavelength = 0.6
</pre>
<!-- grep end -->

<p>The calculated n&amp;k values for each region are reported in the log file:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/n2_msh.log" startExpr="*refractive*kappa*" lines=6 footer="..." -->
<pre>
refractive &amp; kappa for each material using (n k) to set cell size:  

-------------------------------------------------
material: Aluminum
M3a:   			(1.2 7.26)
M3b:   			(1.2 7.26)
...
</pre>
<!-- grep end -->

<!--==========================-->
<h2>7.3.2 NodePerWavelength Refinement</h2>

<p>Similar to the <tt>maxCellSize</tt> refinement, the <tt>nodePerWavelength</tt> 
(or <tt>npw</tt>) refinement creates a maximum cell-size refinement. However, 
the actual value is calculated according to the wavelength and the CRI as follows:</p>

<ul>
<li><tt>WavelengthDep Real</tt>: $\text"element size" = \text"wavelength" \/ (|n| ⋅ \text"npw")$</li>
<li><tt>WavelengthDep Imag</tt>: $\text"element size" = \text"wavelength" \/ (|k| ⋅ \text"npw")$</li>
<li><tt>WavelengthDep Real Imag</tt>: $\text"element size" = \text"wavelength" \/ (√{n^2 + k^2} ⋅ \text"npw")$</li>
</ul>

<p>As an example, using <tt>WavelengthDep Real</tt>, a wavelength of 0.5 &mu;m, and 
a refractive index of 2.5 with <tt>npw=10</tt>, Sentaurus Mesh will place 10 nodes 
into the optical length of a wavelength, which corresponds to 0.2 &mu;m in real space. 
Therefore, that the element size would be 0.02 &mu;m.</p>

<p>Figure 5 (<em>left</em>) shows a simplistic case in <tt>example=2</tt>, with a very 
coarse mesh, typically used to quickly run EMW without expecting realistic results:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*example*2*" startOffset=1 endExpr="*#*" endOffset=-1 -->
<pre>
    CRI WavelengthDep real imag
    NPW = 5
    
</pre>
<!-- grep end -->

<p>Note how the y-refinement becomes progressively coarser from bottom to top as the 
refractive index decreases, from silicon with 3.939 to gas with 1.</p>

<p>The finer mesh inside the metal regions is obvious. This is because you switched 
on the imaginary refractive index part for the CRI, which has a large value of 7.26.</p>

<p><a href="images/sm_tp_emw_2-3.png"><img src="images/sm_tp_emw_2-3.png" width="570" 
alt="Tensor meshes for EMW examples 2 and 3" /></a></p>

<p class="caption">Figure 5. (Left) example=2 uses npw refinement with 
&quot;CRI WavelengthDep real imag&quot; everywhere and (right) example=3 uses 
&quot;CRI real&quot; for metal regions. (Click image for full-size view.)</p>

<p>In <tt>example=3</tt> (see Figure 5, <em>right</em>), you switched off the 
imaginary part of the CRI. Therefore, the finer mesh in the metal regions disappears:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*example*3*" startOffset=1 endExpr="*#*" endOffset=-1 -->
<pre>
    CRI WavelengthDep real imag
    CRI material &quot;Aluminum&quot; WavelengthDep real
    NPW = 5

</pre>
<!-- grep end -->

<p>The <tt>npw</tt> refinements can be specified not only globally but also individually 
for each direction (see <tt>example=4</tt>, Figure 6, <em>left</em>):</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*example*4*" startOffset=1 endExpr="*#*" endOffset=-1 -->
<pre>
    CRI WavelengthDep real 
    NPWX = 5
    NPWY = 10

</pre>
<!-- grep end -->

<p>The element size in the y-direction is reduced in all regions.</p>  

<p><a href="images/sm_tp_emw_4-5.png"><img src="images/sm_tp_emw_4-5.png" width="570" 
alt="Tensor meshes for EMW examples 4 and 5" /></a></p>

<p class="caption">Figure 6. (Left) example=4 uses npwx and npwy separately, and 
(right) example=5 uses a materialwise npw setting. (Click image for full-size view.)</p>

<p>In addition, regionwise or materialwise as well as direction-limited specifications 
are possible:</p>

<pre>
npw material &quot;materialName&quot; &lt;integer&gt;
npw material direction &quot;materialName&quot; &quot;x | y | z&quot; &lt;integer&gt;
npw region &quot;regionName"&quot; &lt;integer&gt;
npw region direction &quot;regionName&quot; &quot;x | y | z&quot; &lt;integer&gt;
</pre>

<p>See <tt>example=5</tt> in Figure 6 (<em>right</em>):</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorEMW/tensor_msh.cmd" startExpr="*example*5*" startOffset=1 endExpr="*#*" endOffset=-1 -->
<pre>
    CRI WavelengthDep real 
    NPW = 5
    NPW region &quot;M3a&quot; 30
    NPW material direction &quot;Silicon&quot; &quot;y&quot; 10

</pre>
<!-- grep end -->

<p>All refinements are relaxed to 5 npw, and only the y-refinement in the silicon 
is kept at 10 npw. In addition, the right metal region has a very fine refinement 
of 30 npw.</p>

<!--==========================-->
<h2>7.3.3 Additional Options</h2>

<p>Similar to the <tt>Mesh</tt> subsection previously described, the <tt>EMW</tt> 
subsection offers a <tt>grading</tt> parameter. By default, grading is switched on, 
but it can be switched off with <tt>grading off</tt>. Grading settings in the 
<tt>EMW</tt> subsection overwrite the grading settings in the <tt>Mesh</tt> subsection.</p>

<p>A single element layer is not well represented in EMW because the refractive 
indices are interpolated at the interfaces. Therefore, it is recommended to resolve 
a region with at least two cells in each direction. If an <tt>EMW</tt> subsection is 
present in the command file, by default, Sentaurus Mesh checks whether all layers are 
resolved with at least two elements. This check can be switched off by specifying 
<tt>NoEMWSolverConstraintsCheck</tt> in the <tt>EMW</tt> subsection.</p>

<!--================================================-->
<a name="4"></a>
<h1>7.4 Detecting Short Edges</h1>

<p>For EMW simulations, the shortest edge length is critical for the maximum 
stable time step, which fundamentally determines the runtime. The stable time 
step is calculated using the Courant criteria and is proportional to the shortest 
edge length. Therefore, to achieve the maximum stable time step, short edges must 
be avoided.</p>

<p>To detect short edges, Sentaurus Mesh can report the minimum and maximum edge 
lengths in each coordinate direction, globally as well as for each region in the 
log file. To activate this report, specify <tt>verbosity=3</tt> in the 
<tt>IOControls</tt> section of the command file.</p>

<p>For a simple structure, the report looks like:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorMesh/n2_msh.log" startExpr="*#*cells:*" startoffset=-1 endExpr="*region*name*" endoffset=6 footer="..." -->
<pre>
________________________________________________________
# cells:                          464
# cells in X direction:           16
# cells in Y direction:           29
________________________________________________________
Max cell size in X direction:     0.166667
Min cell size in X direction:     0.1
Max cell size in Y direction:     0.5
Min cell size in Y direction:     0.025
Maximum grading in X direction:   1.66667
Maximum grading in Y direction:   1.96078
________________________________________________________
Region Name                       M1b
Material Name                     Silicon
# cells:                          54
Max cell size in X direction:     0.166667
Min cell size in X direction:     0.166667
Max cell size in Y direction:     0.231029
Min cell size in Y direction:     0.0387475
...
</pre>
<!-- grep end -->

<!--================================================-->
<a name="5"></a>
<h1>7.5 Including Doping Information</h1>

<p>The tensor meshing scheme can be used with doping definitions as discussed in 
<a href="smesh_04.html">Section 4. Doping Definition</a>. To incorporate doping 
into the mesh, call Sentaurus Mesh on the command line or run Sentaurus Mesh from 
within Sentaurus Workbench. In the command file, you can include in the 
<tt>IOControls</tt> section the following line to make the tensor mesh compatible 
with Sentaurus Device:</p>  

<pre>
IOControls {
  ...
  UnstructuredTensorMesh=True
  ...
}
</pre> 

<p>The examples discussed here use a simple NMOS 2D device to demonstrate this 
capability. The example is contained in the Sentaurus Workbench project 
<tt>Applications_Library/GettingStarted/snmesh/TensorDoping</tt>.</p>

<p>The first experiment (<tt>example=2</tt>) defines some constant and analytic
doping profiles as follows:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorDoping/tensor_msh.cmd" startExpr="*Definitions*" lines=5 footer="  ...\n}" -->
<pre>
Definitions {
  Constant &quot;substrate&quot; {
    Species = &quot;BoronActiveConcentration&quot;
    Value = 1e+16
  }
  ...
}
</pre>
<!-- grep end -->

<p>and places this profile in a <tt>Placements</tt> section:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorDoping/tensor_msh.cmd" startExpr="*Placements*" lines=7 footer="  ...\n}" -->
<pre>
Placements {
  Constant &quot;substrate&quot; {        
    Reference = &quot;substrate&quot;
    EvaluateWindow {
      Element = material [&quot;Silicon&quot;]
    }
  }
  ...
}
</pre>
<!-- grep end -->

<p>Figure 7 (<em>left</em>) shows the analytic doping profile.</p>

<p><a href="images/sm_tp_dop.png"><img src="images/sm_tp_dop.png" width="570" 
alt="Doping profiles for examples 2 and 3" /></a></p>

<p class="caption">Figure 7. (Left) example=2 showing an analytic doping profile and 
(right) example=3 showing a submesh doping profile. (Click image for full-size view.)</p>

<p>Finally, an equidistant tensor mesh is defined:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorDoping/tensor_msh.cmd" startExpr="Tensor*" endExpr="}*" -->
<pre>
Tensor {
  Mesh {
    numPointsX = 100
    numPointsY = 1000
  }
}
</pre>
<!-- grep end -->

<p>Figure 8 shows the final mesh.</p>

<p><a href="images/sm_tp_dop_mesh.png"><img src="images/sm_tp_dop_mesh.png" width="570" 
alt="Tensor meshes for doping profiles for examples 2 and 3" /></a></p>

<p class="caption">Figure 8. (Left) example=2 showing an analytic doping profile on an 
equidistant mesh and (right) example=3 showing a submesh doping profile using window 
refinements. (Click image for full-size view.)</p>

<p>The second experiment (<tt>example=3</tt>) incorporates the doping profile from 
an external TDR file:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorDoping/tensor_msh.cmd" startExpr="*Definitions*" startOccurrence=2 endExpr="*Tensor*" endOffset=-1 -->
<pre>
Definitions {
  Submesh &quot;doping&quot; { Geofile = &quot;@pwd@/doping_msh.tdr&quot; }
}

Placements {
  Submesh &quot;doping&quot; { Reference = &quot;doping&quot;  }
}
</pre>
<!-- grep end -->

<p>Figure 8 (<em>right</em>) shows the doping profile. This time, a more sophisticated 
meshing strategy is applied using different, partially overlapping windows to resolve 
the channel and the drain more accurately:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorDoping/tensor_msh.cmd" startExpr="Tensor*" startOccurrence=2 endExpr="}*" -->
<pre>
Tensor {
  Mesh {
    minCellSize direction &quot;x&quot; 0.005
    maxCellSize = 0.05
    window &quot;active&quot; 0 0.365 -0.2 0.2
    maxCellSize window direction &quot;active&quot; &quot;y&quot; 0.005
    window &quot;channel&quot; 0 0.15 -0.005 0.05
    maxCellSize window direction &quot;channel&quot; &quot;y&quot; 0.001
    window &quot;source&quot; 0.1 0.365 0.0 0.14
    maxCellSize window direction &quot;source&quot; &quot;y&quot; 0.002
  }
}
</pre>
<!-- grep end -->

<p>For overlapping <tt>maxCellSize</tt> refinements, Sentaurus Mesh uses the 
smallest value in the overlapping domain.</p>

<!--================================================-->
<a name="6"></a>
<h1>7.6 Tensor Mesh for Garand VE</h1>

<p>Device structures generated from process and topography simulation are based on a 
tetrahedral mesh in TDR format, while input structures for Garand VE (as well as Garand MC) 
must use a rectangular tensor-product mesh. An essential step in the TCAD to SPICE flow 
is the conversion of the process-simulated structure from a tetrahedral mesh to a 
tensor-product mesh.</p>

<p>You can use the tensor meshing scheme (with incorporated doping) of Sentaurus Mesh 
to convert the incoming finite-element mesh to a mesh suitable for simulation with Garand&nbsp;VE. 
To produce a file in TDR format that can be imported into Garand&nbsp;VE, call Sentaurus Mesh from 
the command line:</p>

<pre>
snmesh &lt;file_name&gt;_msh
</pre>

<p>Alternatively, you can run Sentaurus Mesh from within Sentaurus Workbench.</p>

<p>The command file for tensor-mesh conversion has the format:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorGarand/tensor_msh.cmd" startExpr="*IOControls*" endExpr="*end*placements*" -->
<pre>
IOControls {
        InputFile = &quot;@pwd@/prcsim_bnd.tdr&quot;
  EnableTensor
} * end IOControls

Definitions {
  SubMesh &quot;SubMesh&quot; {              
		Geofile = &quot;@pwd@/prcsim_fps.tdr&quot;
  }
} * end Definitions

Placements {
  SubMesh &quot;SubMesh&quot; {
    Reference = &quot;SubMesh&quot;
  }                             
} * end placements
</pre>
<!-- grep end -->

<p>The option <tt>EnableTensor</tt> corresponds to the <tt>-t</tt> command-line option.</p>

<p>Then, a <tt>SubMesh</tt> subsection is defined that contains the data fields (such as 
DonorConcentration and AcceptorConcentration) to be mapped onto the converted tensor-product 
mesh. For mesh conversion for Garand&nbsp;VE, <tt>Geofile</tt> specifies the file containing the data 
fields you want to transfer (usually, <tt>&lt;filename&gt;_fps.tdr</tt>). The data fields 
defined on the external mesh are interpolated to the newly generated tensor-product mesh.</p>

<p>The <tt>Placements</tt> section must include the <tt>SubMesh</tt> profile instance.</p>

<p>The <tt>Tensor</tt> section includes the commands to control the tensor-product mesh generation. 
Remeshing can be applied in the command file to ensure features are resolved properly, by defining 
various tensor-mesh controls in the <tt>Mesh</tt> subsection (see <a href="#2">Section&nbsp;7.2 Basic
Mesh Controls</a>).</p>

<p>The examples discussed here use a 14 nm FinFET to demonstrate tensor mesh conversion for Garand&nbsp;VE. 
The complete project can be investigated from within Sentaurus Workbench in the directory 
<tt>Applications_Library/GettingStarted/snmesh/TensorGarand</tt>.</p>

<p>The first experiment (example T1) uses the default settings for the tensor mesh. Figure&nbsp;9 
shows the converted tensor mesh with doping. Without any control of the remeshing from users, 
the converted mesh is coarse, which might potentially reduce the accuracy of Garand&nbsp;VE simulations.</p>

<p><a href="images/sm_tg_exampleT1.png"><img src="images/sm_tg_exampleT1.png" width="570" 
alt="(Left) Tensor meshes with doping and (right) cut through tensor meshes with doping" /></a></p>

<p class="caption">Figure 9. Tensor mesh example T1 using default settings: 
(left) converted tensor mesh with doping and (right) a cutplane in the middle of channel.
 (Click image for full-size view.)</p>


<p>The second experiment (example T2) applies a more sophisticated meshing strategy 
using different windows:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorGarand/tensor_msh.cmd" startExpr="*T2*" startOffset=1 endExpr="*end*tensor*" -->
<pre>
Tensor {
  Mesh {
    window &quot;finemesh&quot; 0.0 0.036 0.0 0.01 -0.1 0.1
	window &quot;finemesh1&quot; 0.0 0.036 0.0 0.01 0.1 0.2
	window &quot;finemesh2&quot; 0.0 0.036 0.0 0.01 -0.2 -0.1
    
    maxCellSize window &quot;finemesh&quot; 0.0015
    
    maxCellSize window direction &quot;finemesh&quot; &quot;x&quot; 0.00075
    maxCellSize window direction &quot;finemesh&quot; &quot;y&quot; 0.00075
    
	maxCellSize window &quot;finemesh1&quot; 0.00075		
	maxCellSize window &quot;finemesh2&quot; 0.00075
    
    Doping
  }
} * end Tensor
</pre>
<!-- grep end -->

<p>As shown in Figure 10, the converted mesh is much denser than in example T1, 
and the corner of the fin is resolved more accurately.</p>

<p><a href="images/sm_tg_exampleT2.png"><img src="images/sm_tg_exampleT2.png" width="570" 
alt="(Left) Tensor meshes with doping and (right) cut through tensor meshes with doping" /></a></p>

<p class="caption">Figure 10. Tensor mesh example T2: (left) converted tensor mesh with 
doping, which is quite dense, and (right) a cutplane in the middle of channel where the 
corner of the fin is resolved more accurately than in example T1. (Click image for full-size view.)</p>

<p>If the tensor mesh is very dense, it results in longer simulation times for Garand&nbsp;VE. 
Therefore, when converting tensor meshes for Garand&nbsp;VE, a balance between finer feature resolution 
and faster simulation time should be considered.</p>

<p>The third experiment (example T3) applies a relaxed meshing strategy compared to example T2. 
Figure&nbsp;11 shows that the mesh is less dense now, particularly in the z-direction, but the 
critical features of the structure, for example, the corner of the fin, are still well resolved.</p>

<p><a href="images/sm_tg_exampleT3.png"><img src="images/sm_tg_exampleT3.png" width="570" 
alt="(Left) Tensor meshes with doping and (right) cut through tensor meshes with doping" /></a></p>

<p class="caption">Figure 11. Tensor mesh example T3 with relaxed meshing strategy: 
(left) converted tensor mesh with doping, where the regions outside the channel have a coarser 
mesh than in example T2, and (right) a cutplane in the middle of channel, where the dense mesh 
remains the same as in example T2. (Click image for full-size view.)</p>

<p>You  can also refine the mesh based on regions defined in the input TDR file. The fourth 
experiment (example T4) applies such a regional refinement strategy:</p>

<!-- grep file="../../Applications_Library/GettingStarted/snmesh/TensorGarand/tensor_msh.cmd" startExpr="*T4*" startOffset=1 endExpr="*end*tensor*" -->
<pre>
Tensor {
  Mesh {
    maxCellSize region &quot;ChFin&quot;  0.0015
    maxCellSize region direction &quot;ChFin&quot; &quot;x&quot; 0.00075
    maxCellSize region direction &quot;ChFin&quot; &quot;y&quot; 0.00075
    
    maxCellSize region direction &quot;SDepi.1&quot; &quot;X&quot; 0.005
    maxCellSize region direction &quot;SDepi.2&quot; &quot;x&quot; 0.005
    
    maxCellSize region &quot;GATEox_1&quot;  0.0015
    maxCellSize region direction &quot;GATEox_1&quot; &quot;x&quot; 0.0005
    maxCellSize region direction &quot;GATEox_1&quot; &quot;y&quot; 0.0005
    
    maxCellSize region &quot;HfO2_1&quot;  0.0015
    maxCellSize region direction &quot;HfO2_1&quot; &quot;x&quot; 0.0005
    maxCellSize region direction &quot;HfO2_1&quot; &quot;y&quot; 0.0005
    
    Doping
  }
} * end Tensor
</pre>
<!-- grep end -->

<p>Figure 12 shows the converted mesh is good overall and the corner of the fin is well resolved.</p>

<p><a href="images/sm_tg_exampleT4.png"><img src="images/sm_tg_exampleT4.png" width="570" 
alt="(Left) Tensor meshes with doping and (right) cut through tensor meshes with doping" /></a></p>

<p class="caption">Figure 12. Tensor mesh example T4 using regional refinement strategy: 
(left) converted tensor mesh with doping and (right) a cutplane in the middle of channel, 
where the corner of the fin is well resolved. (Click image for full-size view.)</p>

<p>Remeshing must be carefully designed, taking advantage of different approaches, depending 
on the device structure. This is particularly important when performing a design-of-experiments, 
because it is often done in TCAD to SPICE flows, where simulation splits are set up with 
different device process parameters and critical dimensions.</p>

<!--================================================-->
<div id="section">
<p>
<a href="../index.html">main menu</a>
&nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;<a href="smesh_menu.html">module menu</a>
&nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;<a href="smesh_06.html">&lt;&lt; previous section</a>
&nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp;<a href="smesh_08.html">next section &gt;&gt;</a>
</p>
</div>

<!--================================================-->
<div id="copyright">
<p>Copyright &copy; 2022 Synopsys, Inc. All rights reserved.</p>
</div>

</div>
</body>
</html>
